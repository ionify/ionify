;
~
{ re:
    { id:  're@ionify'
    , re:  're.re@ionify'
    , of: ['core', 'public', 'sion', 'api']
    , by: ['🙇🏾‍♂️ יהוה 🤲🏾','mike.🇬🇾👨🏾‍💻🇺🇸.lee','team✨ionify']
    , on:  {200709.2    : -4} || -2.20070904
    , to:  {578310044.1 : -8} || -1.57831004408
    , at:  -0.1  ||  -0.013 || "re@'s actual version"
    , ax:  -0.09 || [-0.09] || "what will re@ do? thank You 🙇🏾‍♂️🤲🏾 יהוה 🤲🏾👨🏾‍💻"
    , ex: "juss fuh see wah re@ guhn doooo 😅"
    , do:
        [ 'transcription'
      /*, 're.my@'    , 're.id@',    're.im.am@', 're.do.as.of@', 're.by.in@'
        , 're.on.to@' , 're.at.ax@', 're.re.it.is.we@', 're.go@', 're.if@'*/

        ],
      as:
        { sion      :-0.001, specification:-0.001
        , sensation :-0.001, convention   :-0.001
        },
      is:
        [ "ionify's convention of ensuring all ions: invoked object notations, "
        + "have a re member with a known & consistent form; visit re.re@ for "
        + "a complete explanation of re & its member specifications."

        , "the foundation for sions: structured ions."

        , "setting missing re & re.id on an object with a domain-named member."
        , "setting missing re on a object."

        , "proposed to ~get all ions needed to define, implement & populate re "
        + "with its members."
        ],
      go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , read: 'https://read.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test: 'https://github.com/ionify/ionify/blob/public/ions/re.test.js'
        , code: 'https://github.com/ionify/ionify/blob/public/ions/re.js'
        , talk: 'https://talk.ionify.net/'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      we:
        [ "WARN that RENAMING re@'s CONVENTION re() WILL DAMAGE re@ AND ionify"
        , "HAVE full re@ specification@ & other re@ notes in re.re@ionify."
        , "WILL migrate re.we have's to re.is & rephrase as present-tense acts."
        , "WILL move all non-trivial member-implementations to respective ions"
        ,
        [ "WANT so@@ applying ok@@ passing own each() for version setting."
        , "NEED to group-share ok@@ abstraction for re.do.as.of@ & re.by@."
        , "NOTE so@@ should be done post~re.id to accurately set re.as.anion"
        , "else some ions with top-level-ids will have falsely set re.as.anion"
        , "like find.test@, link.test@ & re.test@"
        ],
        [ "plan to have top-level-ids reference entire sion not just its re & "
        , "this requires id@, ~find, ~share & ~link's compatibility with that."
        ]
        , "want auto-corrected sensed-re.* values, but only adding re.core ones"
        , "want auto-generated re.im+if+on+to, re.go.code+test & re.by:caller 🤓"
        , "want re-implemented checksum auto-selecting core [non-object] values"
        , "want cached checksum with 0 problems 😅 vs. re-calculating each time"
        , "want numeric checksum for simple & comprehensive comparison code👨🏾‍🔬"
        , "like checksum as re.at.checksum 👨🏾‍💻"
        , "like multiple sion with exact re.am's for attribution resolution👨🏾‍💻"
        , "like re.re clearly stating the sion's re@ ion 🤓"
        , "know re.im.re can also indicate an re@ expansion@"

        , "have non-ion warn() proof for teaching about malformed re.* values"
        , "have auto-corrected all malformed re.* & notified whenever preserved"
        , "hope auto-correcting & allowing observation helps effective learning"
        , "have auto-inferred re.ax for re.at:-*, e.g: ax:{0:0} <= at:-0.02"
        , "have implemented core sion.re & its checksum:  🙇🏾‍♂️🤲🏾 יהוה 🤲🏾👨🏾‍💻"
        ]
    },

  valueOf:function
  ionify ()
    { var my =  this
      ionify   .with
      = my['*'].with
      = my. ax .with
      = my. eq .with
      = my. ex .with
      = my. ok .with
      = my. so .with
      ={its:my ,the: {tools:{}}}
      my.fixen = {configurable:false, enumerable:false, writable:false}
      delete my.valueOf <= my
    },

  on:
 '*',
 '*':function
  re( ion )
    { var my = re.with.its
        , RE

      for (var word in ion)
        if( ~  word.search (/@/))
          typeof( RE    =  ion [word])  == 'object' && (my.an (RE)
            &&  (ion.re =   RE  )       && !('id' in RE)
            &&  ( RE.id = word  ))
            ||  ( RE    = void 0)
                                                  //👇🏾NOTE👇🏾{es5.ish.api}
      RE   || (RE    =        ion.re  || (ion.re= {__proto__:String.prototype}))
      RE.id ? (RE.id = String (RE.id)) : (RE.id =  void 0)

      !       RE.re               ? (RE.re =  '')          :
      typeof  RE.re == 'object'  || (RE.re = String (RE.re))
      typeof  RE.hi == 'boolean' || (RE.hi = RE.hi ? String (RE.hi) : false)
      typeof  RE.on == 'number'  || (RE.on = 0.0)
      typeof  RE.to == 'number'  || (RE.to = 0.0)
      typeof  RE.at == 'number'  || (RE.at = 0.0)

      Array.isArray (RE.of) || (RE.of = RE.of ? [String (RE.of)] : [])
      Array.isArray (RE.if) || (RE.if = RE.if ? [String (RE.if)] : [])
      Array.isArray (RE.is) || (RE.is =         [String (RE.is  || "")])
      Array.isArray (RE.go) || 'object'==typeof  RE.go||(RE.go  =  [RE.go||''])

      Object.setPrototypeOf (RE,  String.prototype) //👈🏾NOTE:{es6.api}
      my.ex (RE)
      my.ax (RE)
      my.ok ({re:RE, bit:'by'})
      my.so ({re:RE, bit:'as'})
      my.so ({re:RE, bit:'do'})
      my.eq (RE)
      Object.seal           (RE)  //MUSE 🤔 prevents re.with, wanted or not?...
      Object.defineProperty (ion,'re', my.fixen)
    },

  an:function
  an( re )
    { return Boolean//WARN🚨 THIS solution IS FRAGILE and NEEDs better DESIGN!
              ( (re.by && re.on && re.to && re.at)||(re.as && re.do)
              ||(re.is && re.we)|| re.go || re.it || re.re
              )
    },

  eq:function
  eq(RE)
    { var members = Object.entries ? 'entries' : 'keys'
        , value

      RE.toString =
      RE.valueOf  = function
      checksum   ()
        { if (value) return value

          with (RE)
            value =
            [ String (of)   , String (Object [members] (as))
            , String (by)   , on, to, at  //🚨these may differ🤔
            , String (RE.if), String (Object [members] (RE.do))
            , String (is)
            ].
          join ('...')

          debugging && debug ({debug:['checksum', RE.id, value]})
          return value
        }

      var fixen = eq.with.its.fixen
      Object.defineProperties (RE, {toString: fixen, valueOf: fixen})

      var via       =   eq.with
        , debug     =   via.the && via.the.tools && via.the.tools.debug
        , enabled   =   via.our && via.our.logging && via.our.logging.debug
        , debugging =  (debug && enabled) || (debug = Object, false)
      //WANT 🤔 to eliminate 🚫 doing 🔁 all👆🏾the👆🏾above 🔁 over 😓 & 😓 over
  },

  warning:
    { as: "re.as should be a   {specification@: version@|true|false, ...} object"
    , ax: "re.ax should be a         {version@: version@, ...}            object"
    , do: "re.do should be a  {identification@: version@|true|false, ...} object"
    , by: "re.by should be an {} object, [] array, or '?,?' comma-separated string"
    , ex: "re.ex should be an {} object"
    },

  ok:function
  ok( fix )
    { var warning = ok.with.its.warning
        , RE      = fix.re
        , bit     = fix.bit
        , it      = RE [bit]

      'string' == typeof it && (it = RE [bit] = it.split(','))

      Array.isArray  (it)

        ? it.forEach
              (function next (element)
              {   it [element] = true
              })

        : typeof    it  == 'object'
              ||  ( it  &&                 (RE.ex[bit]  = it)
                  ,(RE   [bit] =  {})
                  , RE.ex[bit] && (RE[bit] [RE.ex[bit]] = true)
                  )

      RE.ex[bit]
      && ok.with.the.tools.warn
      && ok.with.the.tools.warn ({warn: [!0, warning [bit], RE.id, RE]})
    },

  so:function
  so( fix )
    { var warning = so.with.its.warning
        , RE      = fix.re
        , bit     = fix.bit
        , it      = RE [bit]
        , VERSION = (/(\w+(\.\w+)*)(\.(\d+(\.\d+)*)|(-\d+(\.\d+)*))/)
        , version

      'string' == typeof it && (it = RE [bit] = it.split(' '))

      Array.isArray  (it)

        ? it.forEach
              (function next (element)
              {   version = element.match (VERSION)
              ;
              ;   version
                    && (element =   version [1])
                    && (version = +(version [4]  || version [6]))
              ;
              ;   it [element] = version !== null ? version : true
              })

        : typeof    it  == 'object'
              ||  ( it  &&                 (RE.ex[bit]  = it)
                  ,(RE   [bit] =  {})
                  , RE.ex[bit] && (RE[bit] [RE.ex[bit]] = true)
                  )

      bit == 'as' && !RE.id && (RE.as.anion = true)

      RE.ex[bit]
      && so.with.the.tools.warn
      && so.with.the.tools.warn ({warn: [!0, warning [bit], RE.id, RE]})
    },

  ax:function
  ax( RE )
    { var warning = ax.with.its.warning

      'object' == typeof RE.ax
        || (RE.ax && (RE.ex.ax = RE.ax)
        ,  (RE.at < 0)
        ?  (RE.ax = {[Math.abs( Math.ceil( RE.at))]
                    : Math.abs( RE.at) - 1 > 0 || 0
                    })
        :   RE.ax = {})

      RE.ex.ax
        &&  ax.with.the.tools.warn
        &&  ax.with.the.tools.warn ({warn: [!0, warning.ax, RE.id, RE]})
    },

  ex:function
  ex( RE )
    { var warning = ex.with.its.warning

      typeof  RE.ex == 'object'
          || (RE.ex  =  RE.ex ? {ex:RE.ex} : {})

      RE.ex.ex
        &&  ex.with.the.tools.warn
        &&  ex.with.the.tools.warn ({warn: [!0, warning.ex, RE.id, RE]})
    }
}
;
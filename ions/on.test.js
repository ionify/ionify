;
~
{ re:
    { id:  'on.test@ionify'
    , of: ['core', 'public', 'sensation', 'api', 'tests']
    , do: {sensation  :true, transcription:true}
    , as: {examination:true}
    , by: ['ğŸ™‡ğŸ¾â€â™‚ï¸ ×™×”×•×” ğŸ¤²ğŸ¾', 'mike.ğŸ‡¬ğŸ‡¾ğŸ‘¨ğŸ¾â€ğŸ’»ğŸ‡ºğŸ‡¸.lee', 'teamâœ¨ionify']
    , on:  -4.200709
    , to:  -8.20221202
    , at:  -0.023
    , is: "ionify's ~on api examination"
    , go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test: 'https://github.com/ionify/ionify/blob/public/ions/on.test.js'
        , code: 'https://github.com/ionify/ionify/blob/public/ions/on.ion.js'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      we:
        [ "were ..."
        , "must ..."
        , "will ..."
        , "want ..."
        , "like refining suite with ~do:[] & named tests ğŸ‘€ on.duplication.test@"
        ]
    },

  valueOf:function
  test_on()
    { delete this.valueOf <= this

      ~
      { on:'fatherhood',
            fatherhood :function
            fatherhood (action)
              { action.fatherhood === "ğŸ¤ã‹ã„ã¨âœ¨ğŸ§‘ğŸ¾â€ğŸ¦±ğŸ™‡ğŸ¾â€â™‚ï¸âœ¨ã¨âœ¨ğŸ™‡ğŸ¾â€â™‚ï¸ğŸ‘¨ğŸ¾â€ğŸ¦±âœ¨ãƒã‚¤ã‚±ãƒ«ğŸ¤"
              ? ~{  log:"âœ… ~on: reaction: named & referenced"}
              : ~{error:"âŒ ~on: reaction: named & referenced", halt:false}
      }       }
      ~
      {fatherhood:"ğŸ¤ã‹ã„ã¨âœ¨ğŸ§‘ğŸ¾â€ğŸ¦±ğŸ™‡ğŸ¾â€â™‚ï¸âœ¨ã¨âœ¨ğŸ™‡ğŸ¾â€â™‚ï¸ğŸ‘¨ğŸ¾â€ğŸ¦±âœ¨ãƒã‚¤ã‚±ãƒ«ğŸ¤"}

      var dsr = "~on: reaction: dynamicâœ¨selfâœ¨reaction: named, unreferenced & future-defined:"
      ~
      { on:'something', something:'whoa!!!'}
      ~
      { something :'hi'
      ,'whoa!!!'  :function
        whoa()
          {
          ~ {log: "âœ… YES! ğŸ™‡ğŸ¾â€â™‚ï¸ ×™×”×•×” ğŸ¤²ğŸ¾ !THANK YOU âœ…"}
          + {log:["âœ…", dsr, "function"]}
      }   }
      ~
      { something :'hi'
      ,'whoa!!!'  :
          [ {log: "âœ… YES! ğŸ™‡ğŸ¾â€â™‚ï¸ ×™×”×•×” ğŸ¤²ğŸ¾ !THANK YOU âœ…"}
          , {log:["âœ…", dsr, "aeon"]}
        //, { no:'whoa!!!'||'@this', on:'something'}
          ]
      }
      ~
      { no:'whoa!!!', on:'something'}
      ~
      { something:'ğŸ˜¬ Â¡sdoops! ğŸ˜¬'
      , 'whoa!!!':{error:["âŒ", dsr, "~no"], halt:false}
      }


      ~
      { on:'ion@doma.in',
          'ion@doma.in':function
              on_ion_id (action)
                {   action.re.id    === 'ion@doma.in'
                &&  action.re.is    === "an re ionified module"
                ||  action.re.is[0] === "an re ionified module"
                ?  ~{  log:"âœ… ~on: reaction: named via re.id"}

                :   action['ion@doma.in'].is    === "a top-level-id ionified module"
                ||  action['ion@doma.in'].is[0] === "a top-level-id ionified module"
                ?  ~{  log:"âœ… ~on: reaction: named via top-level-id"}

                :  ~{error:"âŒ ~on: reaction: named via top-level-id & re.id", halt:false}
      }         }
      ~
      {re:
        { id: 'ion@doma.in'
        , by: 'mike.ğŸ‘¨ğŸ¾â€ğŸ’».lee@ionify'
        , on: -8.20171111
        , to: -7.20220623
        , in: 'san-jose.california.usa.earth'
        , is: "an re ionified module"
      } }
      ~
      {'ion@doma.in':
        { by: 'mike.ğŸ‘¨ğŸ¾â€ğŸ’».lee@ionify'
        , on: -8.20171111
        , to: -7.20220623
        , in: 'san-jose.california.usa.earth'
        , is: "a top-level-id ionified module"
      } }

      ~
      { on:
       'action',
       'action':  function
        reaction1 (action)
          { (action.on != 'action' && typeof action.action != 'function')
                ? ~{  log:"âœ… ~on: reaction: per sensation: selfless"}
                : ~{error:"âŒ ~on: reaction: per sensation: selfless", halt:false}

            ++action.count == 1
                ? ~{  log:"âœ… ~on: reaction: per sensation: once"}
                : ~{error:"âŒ ~on: reaction: per sensation: once", halt:false}

            ~ {no:reaction1, on:'action'}
          }
      }

      ~
      { on:
       'action',
       'action':  function
        reaction2 (action)
          { ++action.count == 2
                ? ~{  log:"âœ… ~on: reaction: per sensation: multiple"}
                : ~{error:"âŒ ~on: reaction: per sensation: multiple", halt:false}

            ~ {no:reaction2, on:'action'}
          }
      }

      ~
      {action:'activation',count:0}

      ~
      { on:
          [ ['compound-term', 'reaction']
          ,  'single-term------reaction'
          ,             '*'
          ],
        '*':       function
        convention (action)
          { if (convention == action.no) return  ~{log: "âœ… ~on: convention"}
            if (convention.happened    ) return; else convention.happened = true
          ~ {on:convention.with.its.re.id, no:convention}
          //~on:* keeps & maps reactions to their ids, not '*' <= Â¿ğŸš¨ to fix?
          //~on:* keep  & map  could  do {'*':[reaction,reaction,...]}
          //~on:* would automatically do this if multi-reaction *-sensation created
          }
          ,
       'single-term------reaction':function
        single_termed____reaction ( action )
          {
          ~ {log: "âœ… ~on: reaction: term: single"}
          }
          ,
       'compound-term reaction':function
        compound_term_reaction ( action )
          {
          ~ {log: "âœ… ~on: reaction: term: compound"}
          }
      }
      ~ {'compound-term':'sensed', reaction :true}
      ~ {'single-term------reaction'        :true}

      ~
      { get:
          [ 'on.duplication.test@ionify'  //ğŸš¨ ~get a multi-reaction-sensation
          , 'on.duplication.test@ionify'  //ğŸš¨ thrice to test if it self-reacts &
          , 'on.duplication.test@ionify'  //ğŸš¨ if any of its duplicates self-react
          ]
      }

      // more tests can be added below here...
    }
}
;
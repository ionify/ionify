;
~
{ re:
    { hi:   true
    , id:  're.hi@ionify'
    , of: ['more', 'public', 're', 'sion', 'api']
    , by: ['🙇🏾‍♂️ יהוה 🤲🏾', 'mike🇬🇾👨🏾‍💻🇺🇸lee', 'team✨ionify']
    , on:  -2.20070904
    , to:  -1.57831005508
    , at:  -0.003
    , do: {'on.storie@ionify':true, transcription:true}
    , as: {sensation:-0.001, convention: -0.001}
    , is:
        [ "ionify's re.hi@: handled    invocation, "
        +           "sion@: structured invoked object notation, "
        +      "sensation@: sensing action: active ion."

        , "indicating   an alternate sim: structured ion method for invocation"
        , "implementing an alternate locally-defined ion method for invocation"
        ],
      go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test: 'https://github.com/ionify/ionify/blob/public/ions/re.hi.test.js'
        , code: 'https://github.com/ionify/ionify/blob/public/re.hi.js'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      it:
        [ "..."
        ],
      we:
        [ "KNOW we should keep ions' re.hi method in case reinitiation's needed"
        , "LIKE re.hi == 'ionify' means delete ion.valueOf after +ion.ionify"
        , "MUSE 🤔 ¿should 👍🏾re.hi:true=hiphop|hip or 👎🏾re.hi:'name'=hiphop|hip?"
        , "WILL implement calling a sim implemented elsewhere, i.e. ~get.ing it"
        ,
        , "must ..."
        , "will ..."
        , "plan ..."
        , "need ..."
        , "want ..."
        , "like ..."
        , "know ..."
        , "care ..."
        , "wish ..."
        , "note ..."
        , "have ..."
        , "dont ..."
        , "wont ..."
        , "cant ..."
        ]
    },

  on:
 '*',
 '*':function
  hi( ion )
    { var method = ion.re && ion.re.hi;
      if(!method)  return //ion is an obi: observable ion & wants to be that 👋🏾

      var hiphop =  false //ion wants to handle its invocation
        ; method === true && (method = 'ionify') && (hiphop = true)

      var via       = hi.with
        , sensing   = via && via.the && via.the.tools.sensible
        , sensible  ={sensible:method, in:ion}
        ; sensing   = sensing && sensing (sensible) || +sensible

      method = ion [method] || method

      if(!sensing)
        { var missing = via.its.missing
        ~ {warn:missing} + {debug: [true, missing, ion.re]}
        ; return
        }

      ion.re.hi   = false   //🙇🏾‍♂️ ion can handle its own invocation so let it
      ion.valueOf = method  //👨🏾‍💻 by setting its invocation sensor as stated.
      Object.isExtensible   (ion) &&//👨🏾‍🏫 configurable | writable false blocks
      Object.defineProperty (ion,'valueOf',{enumerable:false})  //🤭 hip-hop!
    ~ ion                           //⚛️ invoke the ion's handled invocation &
      hiphop && delete ion.valueOf  //🕺🏾 do hip-hop invocation if specified 🎉
    },

  ionify:function
  ionify()
    { var   hi      = this
      hi['*'].with  ={its:hi}
    },

  missing
    : "re.hi: handled invocation handler function is missing check debug details"
}
;
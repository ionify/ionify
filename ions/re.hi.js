;
~
{ re:
    { hi:   true
    , id:  're.hi@ionify'
    , of: ['more', 'public', 're', 'sion', 'api']
    , by: ['ğŸ™‡ğŸ¾â€â™‚ï¸ ×™×”×•×” ğŸ¤²ğŸ¾', 'mikeğŸ‡¬ğŸ‡¾ğŸ‘¨ğŸ¾â€ğŸ’»ğŸ‡ºğŸ‡¸lee', 'teamâœ¨ionify']
    , on:  -2.20070904
    , to:  -1.57831005508
    , at:  -0.003
    , do: {'on.storie@ionify':true, transcription:true}
    , as: {sensation:-0.001, convention: -0.001}
    , is:
        [ "ionify's re.hi@: handled    invocation, "
        +           "sion@: structured invoked object notation, "
        +      "sensation@: sensing action: active ion."

        , "indicating   an alternate sim: structured ion method for invocation"
        , "implementing an alternate locally-defined ion method for invocation"
        ],
      go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test: 'https://github.com/ionify/ionify/blob/public/ions/re.hi.test.js'
        , code: 'https://github.com/ionify/ionify/blob/public/re.hi.js'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      it:
        [ "..."
        ],
      we:
        [ "KNOW we should keep ions' re.hi method in case reinitiation's needed"
        , "LIKE re.hi == 'ionify' means delete ion.valueOf after +ion.ionify"
        , "MUSE ğŸ¤” Â¿should ğŸ‘ğŸ¾re.hi:true=hiphop|hip or ğŸ‘ğŸ¾re.hi:'name'=hiphop|hip?"
        , "WILL implement calling a sim implemented elsewhere, i.e. ~get.ing it"
        ,
        , "must ..."
        , "will ..."
        , "plan ..."
        , "need ..."
        , "want ..."
        , "like ..."
        , "know ..."
        , "care ..."
        , "wish ..."
        , "note ..."
        , "have ..."
        , "dont ..."
        , "wont ..."
        , "cant ..."
        ]
    },

  on:
 '*',
 '*':function
  hi( ion )
    { var method = ion.re && ion.re.hi;
      if(!method)  return //ion is an obi: observable ion & wants to be that ğŸ‘‹ğŸ¾

      var hiphop =  false //ion wants to handle its invocation
        ; method === true && (method = 'ionify') && (hiphop = true)

      var via       = hi.with
        , sensing   = via && via.the && via.the.tools.sensible
        , sensible  ={sensible:method, in:ion}
        ; sensing   = sensing && sensing (sensible) || +sensible

      method = ion [method] || method

      if(!sensing)
        { var missing = via.its.missing
        ~ {warn:missing} + {debug: [true, missing, ion.re]}
        ; return
        }

      ion.re.hi   = false   //ğŸ™‡ğŸ¾â€â™‚ï¸ ion can handle its own invocation so let it
      ion.valueOf = method  //ğŸ‘¨ğŸ¾â€ğŸ’» by setting its invocation sensor as stated.
      Object.isExtensible   (ion) &&//ğŸ‘¨ğŸ¾â€ğŸ« configurable | writable false blocks
      Object.defineProperty (ion,'valueOf',{enumerable:false})  //ğŸ¤­ hip-hop!
    ~ ion                           //âš›ï¸ invoke the ion's handled invocation &
      hiphop && delete ion.valueOf  //ğŸ•ºğŸ¾ do hip-hop invocation if specified ğŸ‰
    },

  ionify:function
  ionify()
    { var   hi      = this
      hi['*'].with  ={its:hi}
    },

  missing
    : "re.hi: handled invocation handler function is missing check debug details"
}
;
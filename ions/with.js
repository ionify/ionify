;
~
{ re:
    { id:  'with@ionify'
    , re:  'with.re@ionify'
    , of: ['core', 'public', 'sion', 'context', 'api']
    , by: ['🙇🏾‍♂️ יהוה 🤲🏾','mike🇬🇾👨🏾‍💻🇺🇸lee', 'team✨ionify']
    , on: {200709.2    : -4}
    , to: {578311222.1 : -8}
    , at: -0.017
  //, do: {copy:-0.001, recursion:-0.001}
    , as: {connection:-0.001, convention:-0.001, sensation:-0.001}
    , is:
        [ "ionify's .with connection@ convention@"
        , "ionify's connection@ to habitation@s like web@, node@ & more"
        , "merging all locally defined with.* with the ionosphere's collections"
        , "ensuring all ions have their domain collection@ via with.in.domain"
        , "setting  all ions-missing-re.id@domains' with.in.domain to with.all"
        , "ensuring all ions' sensible members have with.* connection@s"
        , "easy in-member association@ connection@ via member.with:the+our"
        , "easy in-member         ion  connection@ via member.with.its+my"
        , "easy name-to-ai resolution  via ai.with.its connection@"
        , "temporarily preserving any ai's replaced .with at re.ex.with"
        ],
      go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , read: 'https://read.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test: 'https://github.com/ionify/ionify/blob/public/ions/with.test.js'
        , code: 'https://github.com/ionify/ionify/blob/public/ions/with.js'
        , talk: 'https://talk.ionify.net/'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      we:
        [
        [ "LIKE sharing recursion@ionify@ tool but'll defer that for now as it"
        , "should be refined to also support copy@with@.s recall-by-id scenario"
        ]
        , "WANT 👨🏾‍💻 ion.with.all not within ion.with.the; set groups:{all,the}"
        , "KNOW 🚨 ~next.id sets ion.with.its to itself when ~next.id.s .with.d"
        , "were 🙇🏾‍♂️ renaming with.the.ionify.groups <= with.the.ionify.spaces"
        , "will migrate fixed(), recursion & copy() to own ions & re.do them"
        ,
        [ "KNOW 🙇🏾‍♂️ with.my is an entirely new object with copies of or"
        , "references to with.its' members if declared ion.with.my:{} 🚨"
        ]
        ,
        [ "will 🧹 migrate copy@with@ to own ion publicly shared via tools"
        , "will 🧹 migrate share@find*share@ to a 'part' parameter of copy@with@"
        ,   { copy:
                { from: null
                , into: null
                , part:
                    { name: true || "only this named member or * if *|+1 false"
                    , name:false || "all  but  named member"
                    ,  '*': true || "all  its  known members"
                    }
                }
            }
        ]
        ,
        [ "MUSE 🤔 how to handle with@s nullifying group values? no, only add."
        , "removing & nullifying should be explicit actions but could allow for"
        , "my.* group."
        , "considering this since with@ currently loads after habitation@ sets"
        , "the pending@on.ion@ value this with@ declaration will likely nullify"
        ]
        ,
        [ "WANT name-to-ion-member resolution for reference-less group sharing"
        , "e.g. with:{our:{thing:'not.evaluated.member@[🙇🏾‍♂️with...|this]'}}? 🤔"
        ,
        , "KNOW 🙇🏾‍♂️ this will eliminate much of ionify's ions' need to be"
        , "hip-hop invocations soley or primarily to set their with@ shares."
        ,
        , "LIKE 🙇🏾‍♂️ ה 🤲🏾 member.dot.path@member@sion@domain resolution-format"
        , "LIKE 🙇🏾‍♂️ ~find.ing member@id@affiliation:caller,this,with,global🤲🏾"
        , "LIKE 🙇🏾‍♂️ ה 🤲🏾 with@ section for flat fully-qualified-resolve-names"
        , "WANT 🎊🙇🏾‍♂️יהוה👨🏾‍💻🎉",{with:{set:{'dot.ted@@domain':'dot.value@ip'}}}
        ,
        , "NOTE that augment+copy@with@ could enable & apply with-declaration"
        , "name-resolution, as it forms, to with.connection@.group depth so we"
        , "can at least have sensed & delegated name-resolutions to that depth!"
        ,
        , "NOTE that now copy@with@ can do arbitrary depth so can resolve to any"
        , "desired or needed depth! THANK YOU 👨🏾‍🔬🎊🙇🏾‍♂️🤲🏾 יהוה 🤲🏾🎉👨🏾‍💻🤓"
        ,
        , "LIKE adding an 'act' parameter to perform an act on each copy entry."
        , "this would help to keep copy@ general while enabling ionify-specific"
        , "acts like name-resolution for entries with string values matching"
        , "to-be-resolved names +| paths."
        ,
        , "NOTE ~find now searches as deeply & widely as possible so .augment()"
        , "will benefit from that when it applies it for name resolution."
        ,
        , "LIKE 🙇🏾‍♂️ with:{...ai@@} indicating ai@path relative to the with! 🤓"
        , "NOTE 🙇🏾‍♂️ ai@:@with, ai@@:@ion, ai@@@:@affiliation:group,domain,etc"
        ]
        ,
        [ "muse 🤔 re.of.* & with.the.* being sensible acquisition@ indications?"
        , "note domain-less re.as +| re.do can be resolved to ion.re.of groups"
        ]
        ,
        [ "LIKE 🙇🏾‍♂️ declared ion.with's prototype as sion WITH instance 👨🏾‍💻"
        , "as a more unobtrusive extension of the ion's original .with which is"
        , "aligned with the .with-declaration's intent & design 🎊🙇🏾‍♂️יהוה👨🏾‍💻🎉"
        ],"want 🙇🏾‍♂️ member.with.my:{__proto__:member.with.its} for private .my"
        , "like 🙇🏾‍♂️ with.my declarations being for [private] internal members"
        , "like 🙇🏾‍♂️ with.our declarations being for [private]  domain members"

        , "were ..."
        , "must ..."
        , "will copy & expand inline augment() & connect() notes into with.re@"
        , "plan ..."
        , "know ..."
        , "like ..."
        ,
        [ "muse 🤔 should we seal WITH * after * vs before it's sion extension?"
        , "muse 🤔 should WITH apply .augment() as a copy constructor?"
        ]
        ]
    },

  on:
  '*',

  with:
    { my: //.......🌱 share with  your .members here 🌱
        { copy:
            { done: {}
            , upto: 3
            , add : {l1:false, l2:true, l3:true}
            , own : {l1: true, l2:true, l3:true}
            , wipe: {}
            , skip: {ionify:true, domain:true, groups:true, spaces:true
                    ,  with:true
                    }
            }
        },
      in: //.......🌱 share with-in your collections 🌱
        { domain://🌱 share with-in your domain here 🌱
            {
            }
        },
      our://.......🌱 share with-in your domain here 🌱
        { states:
            { initiating: false
            }
        },
      all://.......🌱 share with all the ~ions  here 🌱
        { ""        : ""
        , blank     : ""
        , none      : []
        , null      : null
        , nope      : function nothing () {}
        , fixed     : {configurable:false, writable:false}
        , fixen     : {configurable:false, writable:false, enumerable:false}
        , missing   : void 0
        , undefined : void 0
        },
      the://.......🌱 share with-in collections here 🌱
        { ionify://🌱 share with @ionify domain here 🌱
            { groups: null
            , spaces: null  //🗑after refactoring to groups🚨
            , tests:
              { WITH:'WITH@with@ionify'
              }
            },
          tools:
            { fixed:'fixed@@'
            }
        }
    },

  WiTH:                 //👨🏾‍💻 want to migrate to with.my declaration...
    { the: null         //👨🏾‍🏫 the ionosphere's collections
    , all: null         //👨🏾‍🏫 the ionosphere's collection for all ions
    },

  WITH:function
  WITH()                //👨🏾‍💻 want to migrate to with.my declaration...
    { this.our  = null  //👨🏾‍🏫 the ion's domain collection
      this.in   =   {}  //👨🏾‍🏫 the ion's collections
      this.its  = null  //👨🏾‍🏫 the ion & its members for external access
      this.my   = null  //👨🏾‍🏫 the ion & its members for internal access
    },

  valueOf:function
  ionify()
    { var         my    = this
        ,        via    = my.with
        ,        all    = via.all
        ,        the    = via.the
        ,       form    = my['*']
        ,       WiTH    = my.WiTH
        ,      fixed    = my.fixed
        ,     iOnify    = via.the.ionify
        ,    augment    = my.augment
      my.sensible.with  =
      my.members.with   =
      my.connect.with   =
      my.combine.with   =
      my.copy.with      =
      augment.with      =
      fixed.with        =
      form.with         ={in:via.in, my:my, its:my, all:all, our:iOnify}

      the.tools.fixed       = fixed
      augment.recursion     = my.recursion (augment)
      my.WITH.prototype.the = WiTH.the = iOnify.spaces      = the
      my.WITH.prototype.all = WiTH.all = iOnify.spaces.all  = all

    //Object.freeze (my)                    //🛡 singleton with@ <= CANT BUT WHY?
      Object.freeze (my.WITH) /*👇🏾CANT👇🏾*/  //🛡 singleton ionosphere constructor
      fixed         ([all,WiTH/*,fixed*/])  //🛡 singleton ionosphere .all & .the
      delete my.valueOf <= my
    },

   '*': function
  _with_( ion )
    { var via = _with_.with
      return via.my.augment (ion)
    },

  fixed:function
  fixed (next)
    { Array.isArray (next) || (next = [next])

      for
        ( var its
        ,     FIXED = fixed.with.all.fixed
        ,     thing = next.length
        ;     its   = next[--thing]
        ;
        )
        { if(!Object.isExtensible (its)) continue

          for
            ( var it in its ) //🛡 keep initial its.*
            { its.hasOwnProperty    (it)  &&
              Object.defineProperty (its, it, FIXED)
            }
        }
    },

  sensible:function
  sensible (ion)
    { if (sensible.found) return sensible.found

      var via =  sensible.with

      return ion
          && (    ion.re.id.domain ||    ion.re.id).name
          == ( via.my.re.id.domain || via.my.re.id).name
          && (sensible.found = ion.with && ion.with.our.ionified)
          || via.all.none
    },

  recursion:function
  recursion (routine)
    { return  { depth: 1
              , known: []
              , later: false
              , delve: routine,

                defer:function
                defer (which)
                  { this.knows (which)
                  },

                knows:function
                knows (which)
                  { var known = this.known
                    if(~known.indexOf (which))  return true
                       ;known.push    (which);  return false
                  },

                visit:function
                visit ( which)
                  { if( which)
                      { if (!this.later && this.knows (which))
                        return false
                        this.delve.d = true
                      ++this.depth
                        this.delve (which)
                        this.leave ()
                        this.delve.d = false
                        return true
                      }

                    if( this.later || !this.known.length)
                    return false; else this.later = true

                    for
                      ( var next  = this.known
                      ,     item  = -1
                      ;  ++ item  < next.length
                      ;    (which = next [item])
                      &&    this.visit (which)
                      );    this.later = false
                      ;     this.leave ()

                    return true
                  },

                leave:function
                leave ()
                  { if( this.depth --> 2) return
                    if(!this.later)
                      { this.known.length = 0
                      } this.depth        = 1
                  }
              }
    },

  members:function
  members (ion)
    { if (!ion) return

      var has       , vith
        , partial   , member
        , via       = members.with
        , me        = via.my
        , WITH      = me.WITH
        , recursion = me.augment.recursion
        , sensible  = via.our.ionified
        ; sensible ||(sensible = me.sensible.found || me.sensible (ion))

      for //🙇🏾‍♂️ perform with@ augmentation for all the ion's sensible members🧐
        ( var name in ion)                        //👨🏾‍🏫 inspecting each member
        { if( name == 'with')                     continue  //👨🏾‍🏫 except .with
          if(!ion.hasOwnProperty (name))          continue  //👨🏾‍🏫 & inherited.

          member = ion [name]                               //👨🏾‍💻 affirm member

          if(!member)                             continue  //👨🏾‍🏫 exists & is a
          if(!sensible [typeof member])                     //👨🏾‍🏫 sensed type |
          if(!sensible [member.constructor.name]) continue  //👨🏾‍🏫 sensed Type &

          if( member.hasOwnProperty ('with'))               //👨🏾‍🏫 has own .with
          if(  has  =   member.with)                        //👨🏾‍🏫 that exists &
          if(  has  instanceof WITH)              continue  //👨🏾‍🏫 isn't a with@
          else                                              //👨🏾‍🏫 but it's some
          if(!(has  instanceof Object))           continue  //👨🏾‍🏫 object type
          else                                              //👨🏾‍🏫 partial with
            { partial =  (has.all || has.in || has.our || has.the)
                      ?   member
                      :   ion
              has.its || (has.its = has.my  || partial)     //👨🏾‍💻 minus .its &
              has.my  || (has.my  = has.its || partial)     //👨🏾‍💻 minus .my, so
              recursion.defer (member)      ;     continue  //👨🏾‍🔬 augment later

              if( recursion.visit (member))                 //👨🏾‍🔬 augment now
              if( member.with instanceof WITH)    continue  //👨🏾‍🏫 with@ formed
            }

          vith        = new WITH              //👨🏾‍💻 affirm or make a full with@
          vith.its    = vith.my = ion         //👨🏾‍💻 set with@.s its & my to ion
          me.connect  ({ion:ion, with:vith})  //👨🏾‍🔬 and connect its collections
          member.with = vith                  //👨🏾‍💻 set the member's full with@
          me.conceal (member)                 //👨🏾‍🔬 set as an unobtrusive with@
        }
    },

  augment:function
  augment (ion)
    { if (!ion) return false

      var vith
        , via       = augment.with
        , me        = via.my
        , WITH      = me.WITH
        , recursion = augment.recursion
        , later     = recursion.later

      me.members (ion)

      var part = ion.with                   //🙇🏾‍♂️ may have a partial with@ ion
      if( part instanceof WITH) return part //👨🏾‍🏫 a full with@ ion = with@ done
      if( augment.d && ! later) return true //👨🏾‍🏫 means members' with@ are set!

      var  its = part && part.its       //🙇🏾‍♂️ get the ion's partial with@.s its
        ,   my = part && part.my        //👨🏾‍🏫 and the ion's partial with@.s my
        ; vith = new  WITH              //👨🏾‍💻 create a full with@ for this ion

      if( part &&                           //🙇🏾‍♂️ it's a partial with@ with
        ( ( my && my .with) instanceof WITH //👨🏾‍🏫 full with@ .my, or a
        ||(its && its.with) instanceof WITH //👨🏾‍🏫 full with@ .its, so set its
        ))
        { vith.its = its || my              //👨🏾‍💻 full with@.s its to partial's
          vith.my  = my  || its             //👨🏾‍💻 full with@.s my  to partial's
        }
      else
        { vith.its = vith.my  = ion }       //👨🏾‍💻 set with@.s its & my as ion's

      me.connect ({ion:ion, with:vith}) //🙇🏾‍♂️ and connect the ion's collections
      ion.with =  vith                  //👨🏾‍💻 then set|replace the ion's with@,
      me.conceal (ion)                  //👨🏾‍🔬 and set its with@ as unobtrusive.
    ! later && recursion.visit ()       //👨🏾‍🔬 do deferred recursion if not done
      return vith                       //👨🏾‍🔬 ion's with@ augmentation's done ✅
    },

  conceal:function
  conceal (within)
    {   Object.isExtensible   (within)
    &&  Object.defineProperty (within, 'with', {enumerable:false})
    },

  connect:function
  connect (which)
    { var via     =   connect.with
        , i       =   via.my
        , all     =  {l1:true, l2:true, l3:true}
        , groups  =   via.our.spaces || via.the.ionify.spaces
        , ion     =   which.ion
        , vith    =   which.with
        , part    =   ion.with
        , our     =   part && part.our
        , ins     =   part && part.in
        , re      =   ion.re  ||  vith.my.re    || vith.its.re
        , domain  =       re  && (re.id
                              && (re.id.domain  && re.id.domain.name))
                              ||  ''

      ins && i.copy ({from:ins, into:groups, add:all})

      vith.our  =   domain  == ''
                ?   vith.in.domain    =   vith.all
                :   vith.in.domain    =
                    vith.in [domain]  =
                    vith.the[domain]  =   groups [domain]
                                      || (groups [domain] = our || {});

      i.combine (which) //🤲🏾 with@ is formed! 🎉
    },

  combine:function
  combine (which)
    { var via   = combine.with
        , i     = via.my
        , WITH  = i.WITH
        , vith  = which.with
        , ion   = which.ion
        , part  = ion.with
        , its   = part && part.its
        , my    = part && part.my
        , our   = part && part.our

      if( !part                             //🙇🏾‍♂️ with@less, or
        || part             instanceof WITH //👨🏾‍🏫 pre-formed full with@, or
        ||(my  && my .with) instanceof WITH //👨🏾‍💻 partial vs declared with@ or
        ||(its && its.with) instanceof WITH //👨🏾‍💻 partial vs declared with@ or
        ) return                            //🤲🏾 end with@ formation 👨🏾‍🏫🎉

      var more                              //🙇🏾‍♂️ prepare to copy the ion's
        = { the: part.the ,  in: part.in    //👨🏾‍💻 .with-stated with@-compatible
          , all: part.all , our: our        //👨🏾‍💻 members and each of their
          , its: its      ,  my: my         //👨🏾‍💻 values.
          }

      var skip =  vith.its  !== vith.my ? {its:true, my:true} : {}
        ; skip = (skip.with   = true, skip)
      var wipe =  i === ion   ? {l3:true} : via.all.none

      i.copy ({into:vith, from:more, wipe:wipe, skip:skip}) //🙇🏾‍♂️ copy with &
      ion.re && ion.re.ex && (ion.re.ex.with = part)    //👨🏾‍💻 keep it in re.ex
    },

  copy:function
  copy (what)
    { var from  = what.from
        , into  = what.into

      if( from === into || !(from && into)) return

      var via   = copy.with
        , soon  = via.my.with && via.my.with.my || via.my
        , none  = via.all.none
        , upto  = what.upto || copy.upto  || 5764
        , add   = what.add  || copy.add   || soon.copy.add  || none
        , own   = what.own  || copy.own   || soon.copy.own  || none
        , skip  = what.skip || copy.skip  || soon.copy.skip || none
        , wipe  = what.wipe || copy.wipe  || soon.copy.wipe || none
        , name  = [],    at ,  id, fresh  ,  those,   these
        ; copy.count        ||(copy.count = 0)

      for //🙇🏾‍♂️ copy things as specified
      ( var thing in from
      )
      { at =( name.push ('l', copy.count + 1)
            , name.join ('')
            );name.length=0

        if( skip[thing] )                             continue
        if( own [at] && !from.hasOwnProperty (thing)) continue

        these = into [thing]
        those = from [thing]
        fresh = !these && !(thing in into)

        if( these      ===  those)                    continue
        if(!fresh && !wipe [at] && !those)            continue
        if( fresh &&  add [at] === false)             continue
        if( fresh ||  wipe[at]) {into[thing] = those; continue}

        id =( name.push (thing,':',typeof those)
            , name.join ('')
            );name.length=0

        copy.count++
        copy.done ||  (copy.done = {})
        copy.done [id] !==  these  &&
        copy.count      <   upto   &&
       (copy.done [id]  =   these) &&
        copy({from:those, into:these, upto:upto, add:add, own:own, wipe:wipe, skip:skip})
        copy.count--
      } copy.count || (copy.done = {})
    }
}
;

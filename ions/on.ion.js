;
~
{ re:
    { id:  'on.ion@ionify'
    , re:  'on.ion.re@ionify'
    , of: ['core','public','conduit','api','launch']
    , as: { observation :-0.001, sensation    :-0.001 }
    , do: { resolution  :-0.001, transcription:-0.001 }
    , by: ['ğŸ™‡ğŸ¾â€â™‚ï¸ ×™×”×•×” ğŸ¤²ğŸ¾', 'mikeğŸ‡¬ğŸ‡¾ğŸ‘¨ğŸ¾â€ğŸ’»ğŸ‡ºğŸ‡¸lee', 'teamâœ¨ionify']
    , on: {200709.2    : -4}
    , to: {578311211.1 : -8}
    , at: -0.090
    , is:
        [ "ionify: invoked object notation implemented for you"
        , "enabling the ionosphere: invoked object notation observation sphere"
        , "sensing ~{} oli: object literals as invoked Object instances"
        , "sensing ~object_reference  orion as invoked Object instances"
        , "sensing ~on actions"
        , "sharing core actions & information via the core @ionify domain group"
        , "sharing ionified [typeof ion && ion.constructor.name] utility"
        , "ionifying all ions that were ~get.d before ionify's core conventions"
        ],
      go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , read: 'https://read.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test:
              [ 'https://github.com/ionify/ionify/blob/public/ions/on.ion.test.js'
              , 'https://github.com/ionify/ionify/blob/public/ions/on.test.js'
              , 'https://github.com/ionify/ionify/blob/public/ions/on.duplicate.test.js'
              ]
        , code: 'https://github.com/ionify/ionify/blob/public/ions/on.ion.js'
        , talk: 'https://talk.ionify.net/'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      we:
        [
        [ "NOTE âœ¨ many more plans, ideas & issue notes are in on.ion.re@ionify"
        , "LIKE enacting a best-practice of intentionally keep critically"
        , "essential & actionable notes in ion@ & others in ion.re@"
        , "WILL ğŸ™‡ğŸ¾â€â™‚ï¸ set all ionify sions' re.go.deal: https://deal.ionify.net"
        ]
        , "WERE adding a suspension map to support ~re.do.as relations ~get.ing"
        , "WANT ionify@ group inaccessible via ion.valueOf.with:our & in.domain"
        , "want â© to replace group.test() with .hasKnownWord()"
        ,
        [ "WERE ğŸ‘¨ğŸ¾â€ğŸ’» migrating on.ionified here & with@ sharing as a public tool"
        , "WERE ğŸ‘¨ğŸ¾â€ğŸ’» beginning sensible <= on.ionified migration"
        , "WILL ğŸ‘¨ğŸ¾â€ğŸ’» rename sensible <= ionified; confirms sensible ion types"
        , "want ğŸ™‡ğŸ¾â€â™‚ï¸ boolean < {sensible:'name', in:object} +find-resolved ğŸ¤²ğŸ¾"
        , "like + {is:thing, type:'sensible'} <= sensible [typeof todo]"
        ]
        ,
        [ "MADE ğŸ›¡ sure no sense@on.ion@ sensation@ observation@ misapplication"
        , "MUST ensure no /sensed@@/ reaction to new /sensation@s'/ known terms"
        , "WILL ğŸ‘¨ğŸ¾â€ğŸ’» replace sense@tools@ionify <= sense@ionify group sharing"
        , "LIKE ğŸ‘¨ğŸ¾â€ğŸ’» renamed sense's ionify --> sensed --> on concise callstack"
        , "want redesigned on:[[]] to reduce manual combinations' specification"
        , "like setting ion.re.as to its sensed implementation@, e.g. sensation@"
        , "like â© application@ catalyst re.as.configuration for fast initiation"
        , "MUSE ğŸ¤” should re.as.sensation:true be set for all sensed sensations?"
        ]
        ,
        [ "WERE ğŸ™‡ğŸ¾â€â™‚ï¸ exploring with-resolution syntax ğŸ¤“ğŸ‘¨ğŸ¾â€ğŸ’»ğŸ¤²ğŸ¾"
        , "LIKE ğŸ™‡ğŸ¾â€â™‚ï¸ with:ai@@ indicating ai@group relative to the with ğŸ¤“"
        , "NOTE ğŸ™‡ğŸ¾â€â™‚ï¸ ai@:@with, ai@@:@ion, ai@@@:@affiliation:group,domain,etc"
        ]
        ,
        [ "WERE sharing .coventions() anticipating observation@ application(s)"
        , "will make a way to deactivate all observation@s, aka ~on:Type's."
        , "MUST ğŸ§¹ auto-update ionified:observation@ list's deactivated Types"
        , "will create observation@ delegator & have it do prep@sensed@on.ion@"
        , "want .sensible() within a core observation@ delegator vs convention@"
        , "want ionify@ = core observation@ routing to others post-convention@s"
        ]
        ]
    },

  with:
    { my:
        {//pending : null //uncomment when|if able to ~with, pre-habitation@ set
        },
      our:
        { sense     : 'sense@on.ion@'           //ğŸ‘¨ğŸ¾â€ğŸ”¬{api.exploration:resolution}
        , does      : []
        , known     : {}
        , senses    : {}
        , states    : {initiation:{}, initiating:true, suspension:{}}
        , ionified  : {boolean:false, null:false, string:false, undefined:false}
        //â˜ğŸ¾sensible
        , tools     : { sense       :'sense@@'
                      , sensed      :'sensed@@'//ğŸ‘ğŸ¾{api.exploration:resolution}
                      , conventions :'conventions@@'
                      }
        }
    , the:{tools:{sensible:'sensible@on.ion@'}} //ğŸ‘¨ğŸ¾â€ğŸ”¬{api.exploration:resolution}
    ,'the.tools.sensible@':'sensible@@'         //ğŸ‘ğŸ¾{api.exploration:resolution}
    },

  on:
    [['sensible', 'in', 'as']
    ,['sensible', 'in'      ]
    , 'sensible'
    , 'ionified'
    ],'sensible in as':'sensible'
    , 'sensible in'   :'sensible'
    , 'ionified'      :'sensible'
    ,

  valueOf:function
  ionify ()
    { var  our
        ,  ionify =   this
        ;  ionify.via.with
        =  ionify.sensible.with = ionify.convention.with
        =  ionify.sensing.with  = ionify.conventions.with
        =  ionify.sense.with    = ionify.sortKnownWords.with
        =  ionify.sensed.with   = ionify.transcribe.with
        = {its: ionify,  the: {}, our: our=ionify.with.our}

    ~ /ğŸ‘¨ğŸ¾â€ğŸ’»ğŸ‘‡ğŸ¾remove once with@ name-to-member resolutionğŸ‘ğŸ¾/
        our.tools.sense   = our.sense   = ionify.sense
        our.tools.sensed                = ionify.sensed
        our.tools.conventions           = ionify.conventions
        ionify.with.the.tools.sensible  = ionify.sensible

        //ğŸ‘¨ğŸ¾â€ğŸ’» accept habitation@'s queue of ions pending
        delete ionify.valueOf <= ionify // ionification
        ionify.object ()
    },

  pending:null,

  object :function
  object ()
    { var ionify = this

      //activateğŸ‘‡ğŸ¾ionosphere:ğŸ‘‡ğŸ¾ionğŸ‘‡ğŸ¾observationğŸ‘‡ğŸ¾sphere
      ionify.sense ({on: Object, Object: ionify.sensed})
      ionify.sense ({on:'on',        on: ionify.sense })
      //note how this ğŸ‘†ğŸ¾ is erased by â˜ğŸ¾ exact-named term
      ionify.sense (ionify) // enables sensing ~sensible

      for //ğŸ™‡ğŸ¾â€â™‚ï¸ invoke initiation@.s ~on actions
        ( var next    =     ionify.pending
        ,     pending =-1,  last= next.length
        ;   ++pending   <   last
        ;     ionify.sensed(next [next [pending]])
        );

      return true
    },

  sensible: function
  sensible  (action)
    { var    as = action.as || action.sensible
        , within= action.in
        , thing = within && within [as]
        ,  type = thing ===  null ? 'null' : typeof thing
        ,   via = sensible.with
        ,   our = via.our
        ,  find = our.find      ||(via.all && via.all.nope) || Object
        ,    is = our.ionified  ||(via.all && via.all.none)
        ;    is = is [type]     || is [thing && thing.constructor.name]

      return Boolean (is || find ({find:thing, in:within, as:as}))
    },

  activate :function
  activate (ion)
    { var ionify = activate.with.its.object
        , domain = activate.with.our
        ; domain.kn0wn
          && (domain.kn0wn != domain.known)
          && (domain.known  = domain.kn0wn) && +ionify
    },

  deactivate :function
  deactivate (ion)
    { var sensors = deactivate.with.its.sensors

      for(var type in sensors.undo)
       if(sensors.hasOwnProperty (type))
          sensors.make[type].prototype.valueOf = sensors.undo [type]
    },

  disable :function
  disable (ion)
    { var domain       = disable.with.our
        ; domain.kn0wn = domain.known
        ; domain.known = { 0 : 0 }
    },

  sense : function
  sense ( sensation)
    { var ionify      = sense.with.its
        , pending     = true
        , initiation  = ionify.sense ===  sensation.on

      if (!sensation    ||  !('on' in sensation)) return  sensation
      if (!initiation)  //ğŸ‘ˆğŸ¾ blocks on@on.ion@ being applied as anğŸ‘‡ğŸ¾observation@
      if ('function'    === typeof sensation.on)  return  ionify.via        (sensation)
      if ( sensation.on === '*' ){ pending = false;       ionify.convention (sensation)}

      var debug = []
      debug.push
         ([ sensation.re && sensation.re.id, 'on:'
          , sensation.on, /*JSON.stringify*/ (sensation)
                          //ğŸ‘†ğŸ¾circular reference errorğŸš¨
          ])

      var groups  = initiation ? ['on']   : sensation.on
      Array.isArray (groups)  || (groups  = [groups])

      var id        = sensation.re && sensation.re.id
        , has       = ionify.hasKnownWord
        , domain    = sense.with.our
        , known     = domain.known
        , sensible  = domain.ionified
        , senses    = domain.senses
        , next      = -1
        , last      = groups.length
        , updated   = {}
        , reaction  , reactions
        , word      , words
        , group
        , spot
        , test
        , senseless

      debug.push (Object.keys (senses))

      while (++next < last)
        { words = group = groups [next]
          Array.isArray  (group) || (words = group = [group])
          group = group.join (' ')

          if('*' === group)
            { pending && ionify.convention (sensation)
            ; pending = false
            ; continue
            }

          senseless  = !senses [group]    // the sensation's terms aren't sensed
          senseless && (senses [group] = [])    // so make them a new terms list

          reactions = senses    [group]
          reaction  = sensation [group]
          reaction
            &&  ( spot = reactions.push (reaction))
            &&  ! sensible  [   typeof   reaction]
            &&  ( domain.find
                ? domain.find ({find:reaction,  in: sensation, as:group})
                && (reactions [spot-1] = reaction = sensation [   group])
                :  (reactions [spot-1] = reaction = sensation [reaction])
                );

          //ğŸ™‡ğŸ¾â€â™‚ï¸ enables simplified per-ion self-reacting sensation@
          groups [group] = reaction //ğŸ‘¨ğŸ¾â€ğŸ’» detection in .sensed() ğŸ¤²ğŸ¾

          debug.push ([id, group in senses ? "knows" : "ignores", group])

          //ğŸ™‡ğŸ¾â€â™‚ï¸intentionally  ğŸ‘‡ğŸ¾keep inactiveğŸ‘‡ğŸ¾ reaction for dynamic-self-reactionsğŸ¤²ğŸ¾
          if(!reaction /*|| !sensible [typeof reaction]*/ || reactions && !senseless)
              continue

          test  = '\treturn "'+ words.join ('" in ion && "') +'" in ion;'
          test  =  new Function ('ion', test)
          group = {act:group, set:words, in:test||has}

          for (var w=words.length; w --> 0;)
            { word  =  words [w]
             !known   [word]  &&  (known [word] = [])
              known   [word].push (group)
              updated [word]   =   true
            }
        }

      ionify.sortKnownWords (updated)
      reactions && sensation.re && (sensation.re.as.sensation = true)

      domain
        ? domain.logging && domain.logging.debug && sense.with.the.tools.debug
          ({debug: (debug.push ([id].concat (groups)), debug.join ('\n'))})
        : +{debug: (debug.push ([id].concat (groups)), debug.join ('\n'))}

      return sensation
    },

  hasKnownWord :function
  hasKnownWord (ion)
    { var words = this.act
    ,     w     = words.length
    ; while (w --> 0 && (ion[words[w]] || words[w] in ion))
    ; return w <=- 1
    },

  sortKnownWords :function
  sortKnownWords (updated)
    { var witH       = sortKnownWords.with
        , known      = witH.our.known
        , descending = witH.its.sortKnownWordsDescending
        , word

      !updated && (updated = known)

      for (word in updated)
        updated.hasOwnProperty (word) && known [word].sort (descending)
    },

  sortKnownWordsDescending :function
  descending (known, nextKnown)
    { return nextKnown.set.length - known.set.length
    },

  convention :function
  convention (sensation)
    { var via     = convention.with
        , our     = via.our
        , sense   = via.its
        , does    = our.does
        , action  = sensation['*']

      our.ionified [typeof action]
        || +{find:action, in:sensation, as:'*'}
        ?   (action = sensation [ '*' ]       )
        :   (action = sensation [action]      )

      //ğŸ™‡ğŸ¾â€â™‚ï¸ save convention pre-application since it'll be self-applied next
      does [sensation.re.id.name || sensation.re.id] = does.push (action) - 1
      //ğŸ‘¨ğŸ¾â€ğŸ’» & may ~no.on itself which this would undo by post-application save

      //ğŸ‘¨ğŸ¾â€ğŸ”¬ apply the convention@ to its sensation@ before applying elsewhere
      sense.always ({do:action, for:sensation}) //ğŸ‘¨ğŸ¾â€ğŸ”¬ then apply it to
      sense.always ({do:action, for:sense})     //ğŸ‘¨ğŸ¾â€ğŸ”¬ this observation@

      for
        //ğŸ™‡ğŸ¾â€â™‚ï¸ apply each convention@ to all
        //ğŸ‘¨ğŸ¾â€ğŸ”¬ pre-connection@ initiation@s:
        ( var launch  = sense.pending
        ,     p=-1,P  = launch.length
        ;  ++ p  < P
        ;   sense.always ({do: action, for: launch [launch [p]]})
        );
    },

  always :function
  always (action)
    { var convention = action.do
        ,         on = action.for
        ; typeof  convention   == 'function'
              ?   convention.call (convention.with.its || on, on)
              :   convention   && ((convention).hasOwnProperty ('in')
             || ((convention.in = on), +convention, delete convention.in))
    },

  conventions :function
  conventions (object)
    { var via = conventions.with
        , our = via.our
        , does= our.does
        , id  = object.re && object.re.id
      if( id && our.states.suspension [id.name || id])  return false
      if(!does.length)                                  return false

      for
        ( var       sense    = via.its
        ,      convention, D = does.length, d=0
        ;     (convention    = does[d])
        ,                  D >      d++
        ; sense.always ({do:convention, for:object})
        );

      return true
    },

  sensing :function
  sensing (object)
    { var via       = sensing.with
        , its       = via.its
        , sensors   = its.sensors
        , core      = sensors.core
        , make      = sensors.make
        , Type      = object.constructor
        , type      = Type.name || String (Type).match (sensors.NAME)[1]
        , sensible  = via.our.ionified

      if( make [type] && object instanceof make [type])
        { core [type]  = typeof object

          sensible [core [type]] ||
         (sensible [core [type]]  = true)
        }
    },

  transcribe :function
  transcribe (whence)
    { var ion           =   whence.ion
        , from          =   whence.from
        , transcription =   transcribe.with.our.logging
        , debugging     =   Boolean (transcription  && transcription.debug)
        , debug         =   debugging && []
        ; debugging     &&  debug.push
                            ('+sion:'
                            , ion.re  ?   ion.re.id
                                      :   ion.with.its
                                      &&  ion.with.its.re
                                      &&  ion.with.its.re.id
                                      ||  'ion')
        ; ion.re         && ion.re.ex &&
        ( ion.re.ex.from ||
        ( ion.re.ex.from  = (from && from.with)? from.with.its.re.id : ion.re.id
        ))
        ; debugging && from    && ( from != transcribe.with.its.sensed)
                    && debug.push ('from',  ion.re  && ion.re.ex.from)
      return debug
    },

  sensedInfo:
    [ /todo: enable ionify's ions to set sensed order of action terms /
    , /todo: senses => ArrayMap to preserve order & fast lookup.      /
    , /idea: log all matched actions & their results?                 /
    , /idea: loop through ion's terms instead of known?               /
    , /done: disable activated words, enable after all matches        /
    , /done: Ignore similar actions after match: ~get ~get.then	      /
    ],

  sensed :function
  sensed (object)
    { object || (object = this)
      var re      =   object.re
        , via     =   sensed.with
        , ion     =   via.its
        , ionify  =   via.our
        , states  =   ionify.states
        , pending =   ion.pending

      if( false   !== states.initiating && re) //ionify .initiation && re)
      if( object  !== pending[re.id && re.id.name || re.id])
      if( re.as   &&         !re.as.anion )
      ion.queue       (object)  //ğŸ‘ˆğŸ¾move into initiation@states@ionify instead?
      ion.sensing     (object)
      ion.conventions (object)

      if( object.re && object.re.id)
      if( states.suspension [object.re.id.name || object.re.id]) return false

      var transcript =
      ion.transcribe  ({ion:object, from:sensed.caller})

      var reaction, reactions
        , group   , groups
        , word    , words
        , result  , before
        , results = 0
        , skip    = {}
        , known   = ionify.known
        , senses  = ionify.senses
        , sensible= ionify.ionified
        , tools   = via.the.tools

      for (word in known)
        { if (!known.hasOwnProperty (word))                   continue
          if (word in skip     || ! (word in object))         continue
          if (senses [word])
          if (senses [word][0] && senses [word][0].with)
          if (object          === senses [word][0].with.its)  continue
          if (object.on       ===         word)               continue

          groups = known [word]

          for
            ( var g=0, G=groups.length
            ;     g  < G
            ;  ++ g
            )
            { group = groups [g]
              if (!group.in (object)) continue

              words     = group.act
              reactions = senses [words]
              before    = results

              for
                ( var r=0,  R= reactions ? reactions.length : 0
                ;     r  <  R
                ;  ++ r
                )
                { reaction = reactions [r]

                  switch (true)
                    { case !reaction
                         :  continue

                      case  object.on         &&
                            object.on [words] &&                          (
                            object.on [words] === reaction                ||  (
                            object.re                                         &&
                            object.re.as.sensation  /*ğŸ‘‡ğŸ¾compare checksums*/   &&
                            object.re ==  String (reaction.with.its.re)       &&
                            object.re.indexOf    ('[object ')   !=   0    )   )
                         :  continue  //â˜ğŸ¾confirm checksum-match not coincidence

                      case  typeof reaction  === 'function':
                        var it   = object.with  ? object.with.its : object
                        result   = reaction.call (it, object)
                        results += 1
                        continue

                      case Boolean (sensible [typeof reaction]):
                      case Boolean (sensible [reaction.constructor.name]):
                        result   = +reaction
                        results += 1
                        continue

                      case Boolean        // got unresolved ğŸ¤”
                        (  ionify         // reaction alias ğŸ§
                        && ionify.find    // so resolve it! ğŸ¤“
                        && ionify.find ({find:reaction, in:object})
                        ): reactions  = [object [reaction]]
                                  R   =  reactions.length
                                  r   = -1
                                  continue

                      default:
                        var temp =
                          [ "inactive reaction -"   , reaction
                          , "- for sensed term(s) -",    words
                          , "- within this object:" ,   object
                          ]
                        transcript
                          && (transcript = transcript.concat (temp))
                          &&  tools.warn  ({ warn:  temp})
                          &&  tools.debug ({debug: (temp.unshift (true), temp)})
                        continue
                    }
                }

              words = group.set
              for (var w=words.length; w --> 0; skip [words [w]] = true);
              if  (results  >  before) break
            }
        }

      transcript    //ğŸš¨ stack overflow caused by
      &&  (object.debug  // infite-looping ~debug
      ||  (object.next   && object.id) //~next.id
      ||   tools.debug   ({ debug: transcript }))

      return results == 1 ? result : object
    },

  sensors:
    { core: {}
    , make: {}
    , undo: {}
    , NAME: (/function\s+(.*)\s*\(/)
    },

  via: function
  via (sensor)
    { var through   = via.with
        , its       = through.its
        , the       = through.the
        , our       = through.our
        , sensible  = our.ionified
        , sensors   = its.sensors
        , core      = sensors.core
        , make      = sensors.make
        , name      = sensors.NAME
        , undo      = sensors.undo
        , Type      = sensor.on
        , type      = Type.name  || String (Type).match (name)[1]
        ; make     [type]         = Type
        ; undo     [type]         = Type.prototype.valueOf
        ; Type.prototype.valueOf  = sensor [type]
        ; core     [type]         = typeof Type
        ; sensible [type]         = true
        ; sensible [core [type]]  = Boolean (core [type])

      Object.isExtensible (Type) &&
      Object.defineProperty
        (  Type.prototype,'valueOf'           //NOTEğŸš¨re.hi:'own'ğŸ”
        , {configurable:false, enumerable:false}//, writable:false}
        )

      the
        &&  our.logging
        &&  our.logging.debug
        &&  the.tools.debug
              ({debug: ['via (sensor)', type, JSON.stringify (sensible)]})

      return true
    }
}
;
